COMPONENTS
==========

Pycorn is made up of a number of parts written in various languages. This is an
attempt to explain what those parts are, and how they fit together. It also
explains the boot process, in vague terms.

1 - The bootloader
==================

This isn't actually part of Pycorn, but it's the first part of the boot
process. For the current supported ARM targets, this is u-boot. It's
responsible for several things:

1) Setting up the SDRAM controller
2) Initialising a serial port
3) Loading the Pycorn kernel from somewhere into RAM
4) Detecting machine type and setting up a taglist, describing the RAM layout
   and boot parameters - this is part of the ARM Linux boot protocol
5) Branching to Pycorn's entry point function, _start

2 - The Pycorn kernel, pykern
=============================

The Pycorn kernel is a C application, with some assembly for initial setup. It
links to libpython.a to provide it with a Python interpreter. It contains
several parts:

2a - The bootstrap entry point
==============================

The bootstrap entry point is written in assembler, and is platform-specific.
It's assembled from arch/$(ARCH)/start.S and produces the executable section
.start which contains the function _start. The link script places .start at the
beginning of the final binary, which means that the entry point is always the
first instruction - also part of the ARM Linux boot protocol. It's responsible
for doing the minimal amount of hardware setup:

1) Allocating space for the bootdata structure and setting the bootdata pointer
   register.
2) Saving the machine type and taglist pointer in the bootdata structure (the
   bootloader passes them in registers r0-r2 which will be overwritten)
3) Setting a temporary stack pointer for the bootstrap code.
4) Calling the C bootstrap, boot_start

It also defines a few MMU setup helper functions which cannot be implemented in
C: mmu_set_base, mmu_enable, and mmu_invalidate_tlb.

2b - The main C bootstrap
=========================

The main C bootstrap is compiled from arch/$(ARCH)/bootstrap.c.

boot_start runs with a valid stack but without the MMU enabled: any references
to virtual addresses must be manually offset to the matching physical address.
It is too difficult to access the .data or .bss sections as they are nontrivial
offsets, so all boot-time data is stored in the bootdata structure, pointed to
by a global register variable and initialised by the assembly entry point. It's
responsible for the rest of hardware setup, creating all the MMU mappings and
then calling mmu_enable, which switches the MMU on, moves to a virtually
addressed stack, and returns to the C bootstrap at boot_after_mmu.

The bootdata struct is no longer accessible in boot_after_mmu as it is not
mapped into the virtual address space, so enable_mmu is responsible for passing
the relevant parameters to this function. It does some MMU cleanups then
branches to newlib's entry point function, _mainCRTStartup

2c - The C library entry point, _mainCRTStartup
===============================================

Now that the MMU is enabled and we have a virtually mapped stack, we can start
to execute code in a more normal C environment. The C library entry point is a
short C function and is still platform-specific - but no longer depends on
particular chip details, only on the architecture in question. It's compiled
from arch/$(ARCH)/crt0.c and produces _mainCRTStartup in the .text section.
It's responsible for doing the "normal" parts of starting a C application,
which are largely the same whether you are running on a real OS or in a
selfhosted environment:

1) Zeroing the memory for the .bss section
2) Registering the global object destructor handler as an atexit() function
3) Calling global object constructors
4) Calling main()
5) Calling exit() if main returns

Global object constructors/destructors are required so that pykern code can use
__attribute__((constructor)) to have functions automatically called on startup.

2c - The boot debug serial driver
=================================

To aid porting and debugging, a serial driver written in native C code exists
which uses the serial port that u-boot set up for us. It supports most memory
mapped 8250/16550-like serial UARTs and only requires the base address from the
platform. It's compiled from arch/$(ARCH)/genmmserial.c. It is used to
implement read() and write() - thus, debug output can be accomplished by simply
printf() or any other ordinary C library mechanism once main() is called.

There is a seperate physical-addressed serial driver in genmmserial-bs.c which
provides functions to print early boot debug messages before the MMU is
enabled.

2d - Python extension modules
=============================

pykern provides several builtin Python extension modules, to allow direct
hardware access. These are the same as any normal Python extension module, with
an additional function tagged as a constructor which is responsible for adding
them to the builtin module table before the interpreter is run. These are
compiled from pykern/*module.c, and produce various modules whose names start
with an underscore.

2e - The pykern main function, main
===================================

pykern's main function is ordinary portable C code. It simply invokes the
Python interpreter with a set of fixed parameters. The standard IO handles will
be attached to the boot debug serial driver, so the interpreter will use that
serial port initially, and for any messages produced in a crash situation.

3 - The Rest
============

Right now that's it - the interpreter produced by pykern simply provides a
prompt using the serial debug port. It is not possible to import any modules
that are not built in, as no filesystem support exists.
