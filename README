Well, this is Pycorn.

Pycorn is an interpreted operating system written in Python, intended to
recreate the easy learning possibilities of 8-bit microcomputers. Device
drivers, file systems, network protocols can all be implemented in Python with
no C or assembler code.

The goal of the project is to create a usable interpreter-centric OS
environment with the capabilities of modern computers; allowing a smooth
learning curve from the acquisition of basic programming skills right up to
implementing new OS-level functionality and drivers. Performance is not a goal,
though it would be nice :) Current development is targeted at a variety of ARM
platforms due to the relative simplicity of the hardware.

LICENSE
=======

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

The directory 'makepp' is a verbatim copy of the original makepp source,
distributed here for convenience. makepp has its own licensing terms in
makepp/LICENSE.

HOW IT ALL FITS TOGETHER
========================

Pycorn currently uses devkitARM to build python, part of wintermute's excellent
devkitpro project (http://www.devkitpro.org/). devkitARM includes a
cross-compiling gcc targetted at generic ARM platforms and a build of the
newlib embedded C library. This provides enough 'stuff' to compile the python
interpreter into a library.

To actually make a bootable image a linker script and entry point are required
which are implemented by pycorn. These are architecture specific and include a
few machine specific details: a small linker script with some platform physica
addresses incluldes the main architecture linker script. The entry point uses a
small amount of assembly then switches to position-independent C code for the
majority of platform setup, then calls a generic C library setup function
written in C.

Right now we only have them for Marvell's PXA270 system-on-chip, as used in the
Gumstix Verdex development board (http://www.gumstix.com). This board can be
simulated by QEMU. A main() function is also required which invokes the python
interpreter with some arguments, and though this is written in C it is
portable.

Of course, it won't actually do anything visible; newlib has no actual IO
facilities. A platform-specific serial debug driver is used for now, hooked up
to newlib's stdin/stdout/stderr.

And.. that's it for now. There is no way to import any modules which aren't
built into the interpreter as all file access fails right now, and Python's
builtin readline is really stupid so you can't even backspace.. but it works!

BUILDING
========

0) Download devkitARM release 23b from
http://sourceforge.net/project/showfiles.php?group_id=114505&package_id=124207
and unpack it somewhere. Add devkitARM/bin to your PATH. You should now be able
to run arm-eabi-gcc and friends. Newer versions of devkitARM do not work as
their build of newlib expects slightly different syscalls.

1) Add the makepp directory in the pycorn source tree to your PATH. makepp is a
nice make replacement with lots of nifty features; used primarily because I
hate make's handling of subdirectories. See http://makepp.sourceforge.net/ for
their project page. I've included a version in the tree because it's a CVS
snapshot, and an uncommon tool.

2) Install u-boot's mkimage utility. This is in Debian as package
"uboot-mkimage", or you can compile it from u-boot's source.

3) Install autoconf. Python's configure script needs regeneration after
patching for cross-compilability.

4) Run "makepp hello/hello.uimage". This is a "hello world" program which
should load into u-boot and print on the default platform serial port.

5a) If you have an actual Gumstix Verdex board you should be able to load this
by serial, tftp, or MMC, and execute it with bootm.

5b) If you don't, you can simulate it under QEMU by doing "makepp hello/run",
assuming you have QEMU installed. The bootloader will be configured
automatically so it should just run. Hit C-a x (C-a a x under screen) to kill
QEMU.

6) Run "makepp pykern/pykern.uimage". This is the python interpreter as a
kernel.

7a) Again, if you have an actual Verdex board it should run from u-boot.

7b) Otherwise, "makepp pykern/run" to launch it in QEMU.
